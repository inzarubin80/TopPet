// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package sqlc_repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addParticipantPhoto = `-- name: AddParticipantPhoto :one

INSERT INTO contest_participant_photos (id, participant_id, url, thumb_url, position)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, participant_id, url, thumb_url, created_at, position
`

type AddParticipantPhotoParams struct {
	ID            pgtype.UUID
	ParticipantID pgtype.UUID
	Url           string
	ThumbUrl      *string
	Position      int32
}

// Contest Participant Photos
func (q *Queries) AddParticipantPhoto(ctx context.Context, arg *AddParticipantPhotoParams) (*ContestParticipantPhoto, error) {
	row := q.db.QueryRow(ctx, addParticipantPhoto,
		arg.ID,
		arg.ParticipantID,
		arg.Url,
		arg.ThumbUrl,
		arg.Position,
	)
	var i ContestParticipantPhoto
	err := row.Scan(
		&i.ID,
		&i.ParticipantID,
		&i.Url,
		&i.ThumbUrl,
		&i.CreatedAt,
		&i.Position,
	)
	return &i, err
}

const addUserAuthProviders = `-- name: AddUserAuthProviders :one
INSERT INTO user_auth_providers (user_id, provider_uid, provider, name)
VALUES ($1, $2, $3, $4)
RETURNING user_id, provider_uid, provider, name
`

type AddUserAuthProvidersParams struct {
	UserID      int64
	ProviderUid string
	Provider    string
	Name        *string
}

func (q *Queries) AddUserAuthProviders(ctx context.Context, arg *AddUserAuthProvidersParams) (*UserAuthProvider, error) {
	row := q.db.QueryRow(ctx, addUserAuthProviders,
		arg.UserID,
		arg.ProviderUid,
		arg.Provider,
		arg.Name,
	)
	var i UserAuthProvider
	err := row.Scan(
		&i.UserID,
		&i.ProviderUid,
		&i.Provider,
		&i.Name,
	)
	return &i, err
}

const countChatMessages = `-- name: CountChatMessages :one
SELECT count(1) FROM contest_chat_messages
WHERE contest_id = $1
`

func (q *Queries) CountChatMessages(ctx context.Context, contestID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countChatMessages, contestID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countCommentsByParticipant = `-- name: CountCommentsByParticipant :one
SELECT count(1) FROM contest_comments
WHERE participant_id = $1
`

func (q *Queries) CountCommentsByParticipant(ctx context.Context, participantID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countCommentsByParticipant, participantID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countContests = `-- name: CountContests :one
SELECT count(1) FROM contests
WHERE (COALESCE($1::text, '') = '' OR status = $1)
`

func (q *Queries) CountContests(ctx context.Context, dollar_1 string) (int64, error) {
	row := q.db.QueryRow(ctx, countContests, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPhotoLikes = `-- name: CountPhotoLikes :one
SELECT count(1) FROM photo_likes
WHERE photo_id = $1
`

func (q *Queries) CountPhotoLikes(ctx context.Context, photoID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countPhotoLikes, photoID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countVotesByContest = `-- name: CountVotesByContest :one
SELECT count(1) FROM contest_votes
WHERE contest_id = $1
`

func (q *Queries) CountVotesByContest(ctx context.Context, contestID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countVotesByContest, contestID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countVotesByContests = `-- name: CountVotesByContests :many
SELECT contest_id, count(1) as vote_count FROM contest_votes
WHERE contest_id = ANY($1::uuid[])
GROUP BY contest_id
`

type CountVotesByContestsRow struct {
	ContestID pgtype.UUID
	VoteCount int64
}

func (q *Queries) CountVotesByContests(ctx context.Context, dollar_1 []pgtype.UUID) ([]*CountVotesByContestsRow, error) {
	rows, err := q.db.Query(ctx, countVotesByContests, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*CountVotesByContestsRow
	for rows.Next() {
		var i CountVotesByContestsRow
		if err := rows.Scan(&i.ContestID, &i.VoteCount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const countVotesByParticipant = `-- name: CountVotesByParticipant :one
SELECT count(1) FROM contest_votes
WHERE participant_id = $1
`

func (q *Queries) CountVotesByParticipant(ctx context.Context, participantID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countVotesByParticipant, participantID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createChatMessage = `-- name: CreateChatMessage :one

INSERT INTO contest_chat_messages (id, contest_id, user_id, text, is_system)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, contest_id, user_id, text, is_system, created_at, updated_at
`

type CreateChatMessageParams struct {
	ID        pgtype.UUID
	ContestID pgtype.UUID
	UserID    int64
	Text      string
	IsSystem  bool
}

// Contest Chat Messages
func (q *Queries) CreateChatMessage(ctx context.Context, arg *CreateChatMessageParams) (*ContestChatMessage, error) {
	row := q.db.QueryRow(ctx, createChatMessage,
		arg.ID,
		arg.ContestID,
		arg.UserID,
		arg.Text,
		arg.IsSystem,
	)
	var i ContestChatMessage
	err := row.Scan(
		&i.ID,
		&i.ContestID,
		&i.UserID,
		&i.Text,
		&i.IsSystem,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createComment = `-- name: CreateComment :one

INSERT INTO contest_comments (id, participant_id, user_id, text)
VALUES ($1, $2, $3, $4)
RETURNING id, participant_id, user_id, text, created_at, updated_at
`

type CreateCommentParams struct {
	ID            pgtype.UUID
	ParticipantID pgtype.UUID
	UserID        int64
	Text          string
}

// Contest Comments
func (q *Queries) CreateComment(ctx context.Context, arg *CreateCommentParams) (*ContestComment, error) {
	row := q.db.QueryRow(ctx, createComment,
		arg.ID,
		arg.ParticipantID,
		arg.UserID,
		arg.Text,
	)
	var i ContestComment
	err := row.Scan(
		&i.ID,
		&i.ParticipantID,
		&i.UserID,
		&i.Text,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createContest = `-- name: CreateContest :one

INSERT INTO contests (id, created_by_user_id, title, description, status)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, created_by_user_id, title, description, status, created_at, updated_at
`

type CreateContestParams struct {
	ID              pgtype.UUID
	CreatedByUserID int64
	Title           string
	Description     string
	Status          string
}

// Contests
func (q *Queries) CreateContest(ctx context.Context, arg *CreateContestParams) (*Contest, error) {
	row := q.db.QueryRow(ctx, createContest,
		arg.ID,
		arg.CreatedByUserID,
		arg.Title,
		arg.Description,
		arg.Status,
	)
	var i Contest
	err := row.Scan(
		&i.ID,
		&i.CreatedByUserID,
		&i.Title,
		&i.Description,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createParticipant = `-- name: CreateParticipant :one

INSERT INTO contest_participants (id, contest_id, user_id, pet_name, pet_description)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, contest_id, user_id, pet_name, pet_description, created_at, updated_at
`

type CreateParticipantParams struct {
	ID             pgtype.UUID
	ContestID      pgtype.UUID
	UserID         int64
	PetName        string
	PetDescription string
}

// Contest Participants
func (q *Queries) CreateParticipant(ctx context.Context, arg *CreateParticipantParams) (*ContestParticipant, error) {
	row := q.db.QueryRow(ctx, createParticipant,
		arg.ID,
		arg.ContestID,
		arg.UserID,
		arg.PetName,
		arg.PetDescription,
	)
	var i ContestParticipant
	err := row.Scan(
		&i.ID,
		&i.ContestID,
		&i.UserID,
		&i.PetName,
		&i.PetDescription,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createUser = `-- name: CreateUser :one

INSERT INTO users (name)
VALUES ($1)
RETURNING user_id, name, created_at
`

// Users
func (q *Queries) CreateUser(ctx context.Context, name string) (*User, error) {
	row := q.db.QueryRow(ctx, createUser, name)
	var i User
	err := row.Scan(&i.UserID, &i.Name, &i.CreatedAt)
	return &i, err
}

const deleteChatMessage = `-- name: DeleteChatMessage :one
DELETE FROM contest_chat_messages
WHERE id = $1 AND user_id = $2 AND is_system = FALSE
RETURNING contest_id
`

type DeleteChatMessageParams struct {
	ID     pgtype.UUID
	UserID int64
}

func (q *Queries) DeleteChatMessage(ctx context.Context, arg *DeleteChatMessageParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, deleteChatMessage, arg.ID, arg.UserID)
	var contest_id pgtype.UUID
	err := row.Scan(&contest_id)
	return contest_id, err
}

const deleteComment = `-- name: DeleteComment :exec
DELETE FROM contest_comments
WHERE id = $1
`

func (q *Queries) DeleteComment(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteComment, id)
	return err
}

const deleteCommentsByParticipant = `-- name: DeleteCommentsByParticipant :exec
DELETE FROM contest_comments
WHERE participant_id = $1
`

func (q *Queries) DeleteCommentsByParticipant(ctx context.Context, participantID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteCommentsByParticipant, participantID)
	return err
}

const deleteContest = `-- name: DeleteContest :exec
DELETE FROM contests
WHERE id = $1
`

func (q *Queries) DeleteContest(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteContest, id)
	return err
}

const deleteContestVoteByUser = `-- name: DeleteContestVoteByUser :one
DELETE FROM contest_votes
WHERE contest_id = $1 AND user_id = $2
RETURNING participant_id
`

type DeleteContestVoteByUserParams struct {
	ContestID pgtype.UUID
	UserID    int64
}

func (q *Queries) DeleteContestVoteByUser(ctx context.Context, arg *DeleteContestVoteByUserParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, deleteContestVoteByUser, arg.ContestID, arg.UserID)
	var participant_id pgtype.UUID
	err := row.Scan(&participant_id)
	return participant_id, err
}

const deleteParticipant = `-- name: DeleteParticipant :exec
DELETE FROM contest_participants
WHERE id = $1
`

func (q *Queries) DeleteParticipant(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteParticipant, id)
	return err
}

const deleteParticipantPhoto = `-- name: DeleteParticipantPhoto :exec
DELETE FROM contest_participant_photos
WHERE id = $1
`

func (q *Queries) DeleteParticipantPhoto(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteParticipantPhoto, id)
	return err
}

const deleteParticipantVideo = `-- name: DeleteParticipantVideo :exec
DELETE FROM contest_participant_videos
WHERE participant_id = $1
`

func (q *Queries) DeleteParticipantVideo(ctx context.Context, participantID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteParticipantVideo, participantID)
	return err
}

const deletePhotoLike = `-- name: DeletePhotoLike :exec
DELETE FROM photo_likes
WHERE photo_id = $1 AND user_id = $2
`

type DeletePhotoLikeParams struct {
	PhotoID pgtype.UUID
	UserID  int64
}

func (q *Queries) DeletePhotoLike(ctx context.Context, arg *DeletePhotoLikeParams) error {
	_, err := q.db.Exec(ctx, deletePhotoLike, arg.PhotoID, arg.UserID)
	return err
}

const deleteVotesByParticipant = `-- name: DeleteVotesByParticipant :exec
DELETE FROM contest_votes
WHERE participant_id = $1
`

func (q *Queries) DeleteVotesByParticipant(ctx context.Context, participantID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteVotesByParticipant, participantID)
	return err
}

const getCommentByID = `-- name: GetCommentByID :one
SELECT id, participant_id, user_id, text, created_at, updated_at FROM contest_comments WHERE id = $1
`

func (q *Queries) GetCommentByID(ctx context.Context, id pgtype.UUID) (*ContestComment, error) {
	row := q.db.QueryRow(ctx, getCommentByID, id)
	var i ContestComment
	err := row.Scan(
		&i.ID,
		&i.ParticipantID,
		&i.UserID,
		&i.Text,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getContestByID = `-- name: GetContestByID :one
SELECT id, created_by_user_id, title, description, status, created_at, updated_at FROM contests WHERE id = $1
`

func (q *Queries) GetContestByID(ctx context.Context, id pgtype.UUID) (*Contest, error) {
	row := q.db.QueryRow(ctx, getContestByID, id)
	var i Contest
	err := row.Scan(
		&i.ID,
		&i.CreatedByUserID,
		&i.Title,
		&i.Description,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getContestVoteByUser = `-- name: GetContestVoteByUser :one
SELECT id, contest_id, participant_id, user_id, created_at, updated_at FROM contest_votes
WHERE contest_id = $1 AND user_id = $2
`

type GetContestVoteByUserParams struct {
	ContestID pgtype.UUID
	UserID    int64
}

func (q *Queries) GetContestVoteByUser(ctx context.Context, arg *GetContestVoteByUserParams) (*ContestVote, error) {
	row := q.db.QueryRow(ctx, getContestVoteByUser, arg.ContestID, arg.UserID)
	var i ContestVote
	err := row.Scan(
		&i.ID,
		&i.ContestID,
		&i.ParticipantID,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getMaxPhotoPositionByParticipant = `-- name: GetMaxPhotoPositionByParticipant :one
SELECT COALESCE(MAX(position), 0) AS max_position
FROM contest_participant_photos
WHERE participant_id = $1
`

func (q *Queries) GetMaxPhotoPositionByParticipant(ctx context.Context, participantID pgtype.UUID) (interface{}, error) {
	row := q.db.QueryRow(ctx, getMaxPhotoPositionByParticipant, participantID)
	var max_position interface{}
	err := row.Scan(&max_position)
	return max_position, err
}

const getParticipantByContestAndUser = `-- name: GetParticipantByContestAndUser :one
SELECT
    cp.id,
    cp.contest_id,
    cp.user_id,
    COALESCE(u.name, 'Пользователь ' || cp.user_id::text) AS user_name,
    cp.pet_name,
    cp.pet_description,
    cp.created_at,
    cp.updated_at
FROM contest_participants cp
LEFT JOIN users u ON u.user_id = cp.user_id
WHERE cp.contest_id = $1 AND cp.user_id = $2
`

type GetParticipantByContestAndUserParams struct {
	ContestID pgtype.UUID
	UserID    int64
}

type GetParticipantByContestAndUserRow struct {
	ID             pgtype.UUID
	ContestID      pgtype.UUID
	UserID         int64
	UserName       string
	PetName        string
	PetDescription string
	CreatedAt      pgtype.Timestamptz
	UpdatedAt      pgtype.Timestamptz
}

func (q *Queries) GetParticipantByContestAndUser(ctx context.Context, arg *GetParticipantByContestAndUserParams) (*GetParticipantByContestAndUserRow, error) {
	row := q.db.QueryRow(ctx, getParticipantByContestAndUser, arg.ContestID, arg.UserID)
	var i GetParticipantByContestAndUserRow
	err := row.Scan(
		&i.ID,
		&i.ContestID,
		&i.UserID,
		&i.UserName,
		&i.PetName,
		&i.PetDescription,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getParticipantByID = `-- name: GetParticipantByID :one
SELECT
    cp.id,
    cp.contest_id,
    cp.user_id,
    COALESCE(u.name, 'Пользователь ' || cp.user_id::text) AS user_name,
    cp.pet_name,
    cp.pet_description,
    cp.created_at,
    cp.updated_at
FROM contest_participants cp
LEFT JOIN users u ON u.user_id = cp.user_id
WHERE cp.id = $1
`

type GetParticipantByIDRow struct {
	ID             pgtype.UUID
	ContestID      pgtype.UUID
	UserID         int64
	UserName       string
	PetName        string
	PetDescription string
	CreatedAt      pgtype.Timestamptz
	UpdatedAt      pgtype.Timestamptz
}

func (q *Queries) GetParticipantByID(ctx context.Context, id pgtype.UUID) (*GetParticipantByIDRow, error) {
	row := q.db.QueryRow(ctx, getParticipantByID, id)
	var i GetParticipantByIDRow
	err := row.Scan(
		&i.ID,
		&i.ContestID,
		&i.UserID,
		&i.UserName,
		&i.PetName,
		&i.PetDescription,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getPhotoLikeByUser = `-- name: GetPhotoLikeByUser :one
SELECT id, photo_id, user_id, created_at FROM photo_likes
WHERE photo_id = $1 AND user_id = $2
`

type GetPhotoLikeByUserParams struct {
	PhotoID pgtype.UUID
	UserID  int64
}

func (q *Queries) GetPhotoLikeByUser(ctx context.Context, arg *GetPhotoLikeByUserParams) (*PhotoLike, error) {
	row := q.db.QueryRow(ctx, getPhotoLikeByUser, arg.PhotoID, arg.UserID)
	var i PhotoLike
	err := row.Scan(
		&i.ID,
		&i.PhotoID,
		&i.UserID,
		&i.CreatedAt,
	)
	return &i, err
}

const getPhotosByParticipantID = `-- name: GetPhotosByParticipantID :many
SELECT id, participant_id, url, thumb_url, created_at, position FROM contest_participant_photos
WHERE participant_id = $1
ORDER BY position ASC, created_at ASC
`

func (q *Queries) GetPhotosByParticipantID(ctx context.Context, participantID pgtype.UUID) ([]*ContestParticipantPhoto, error) {
	rows, err := q.db.Query(ctx, getPhotosByParticipantID, participantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ContestParticipantPhoto
	for rows.Next() {
		var i ContestParticipantPhoto
		if err := rows.Scan(
			&i.ID,
			&i.ParticipantID,
			&i.Url,
			&i.ThumbUrl,
			&i.CreatedAt,
			&i.Position,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserAuthProvidersByProviderUid = `-- name: GetUserAuthProvidersByProviderUid :one
SELECT user_id, provider_uid, provider, name FROM user_auth_providers
WHERE provider_uid = $1 AND provider = $2
`

type GetUserAuthProvidersByProviderUidParams struct {
	ProviderUid string
	Provider    string
}

func (q *Queries) GetUserAuthProvidersByProviderUid(ctx context.Context, arg *GetUserAuthProvidersByProviderUidParams) (*UserAuthProvider, error) {
	row := q.db.QueryRow(ctx, getUserAuthProvidersByProviderUid, arg.ProviderUid, arg.Provider)
	var i UserAuthProvider
	err := row.Scan(
		&i.UserID,
		&i.ProviderUid,
		&i.Provider,
		&i.Name,
	)
	return &i, err
}

const getUserAuthProvidersByUserID = `-- name: GetUserAuthProvidersByUserID :many
SELECT user_id, provider_uid, provider, name FROM user_auth_providers
WHERE user_id = $1
`

func (q *Queries) GetUserAuthProvidersByUserID(ctx context.Context, userID int64) ([]*UserAuthProvider, error) {
	rows, err := q.db.Query(ctx, getUserAuthProvidersByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*UserAuthProvider
	for rows.Next() {
		var i UserAuthProvider
		if err := rows.Scan(
			&i.UserID,
			&i.ProviderUid,
			&i.Provider,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByID = `-- name: GetUserByID :one
SELECT user_id, name, created_at FROM users
WHERE user_id = $1
`

func (q *Queries) GetUserByID(ctx context.Context, userID int64) (*User, error) {
	row := q.db.QueryRow(ctx, getUserByID, userID)
	var i User
	err := row.Scan(&i.UserID, &i.Name, &i.CreatedAt)
	return &i, err
}

const getVideoByParticipantID = `-- name: GetVideoByParticipantID :one
SELECT id, participant_id, url, created_at FROM contest_participant_videos
WHERE participant_id = $1
`

func (q *Queries) GetVideoByParticipantID(ctx context.Context, participantID pgtype.UUID) (*ContestParticipantVideo, error) {
	row := q.db.QueryRow(ctx, getVideoByParticipantID, participantID)
	var i ContestParticipantVideo
	err := row.Scan(
		&i.ID,
		&i.ParticipantID,
		&i.Url,
		&i.CreatedAt,
	)
	return &i, err
}

const listChatMessages = `-- name: ListChatMessages :many
SELECT 
    ccm.id,
    ccm.contest_id,
    ccm.user_id,
    ccm.text,
    ccm.is_system,
    ccm.created_at,
    ccm.updated_at,
    COALESCE(u.name, 'Пользователь ' || ccm.user_id::text) as user_name
FROM contest_chat_messages ccm
LEFT JOIN users u ON u.user_id = ccm.user_id
WHERE ccm.contest_id = $1
ORDER BY ccm.created_at ASC
LIMIT $2 OFFSET $3
`

type ListChatMessagesParams struct {
	ContestID pgtype.UUID
	Limit     int32
	Offset    int32
}

type ListChatMessagesRow struct {
	ID        pgtype.UUID
	ContestID pgtype.UUID
	UserID    int64
	Text      string
	IsSystem  bool
	CreatedAt pgtype.Timestamptz
	UpdatedAt pgtype.Timestamptz
	UserName  string
}

func (q *Queries) ListChatMessages(ctx context.Context, arg *ListChatMessagesParams) ([]*ListChatMessagesRow, error) {
	rows, err := q.db.Query(ctx, listChatMessages, arg.ContestID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListChatMessagesRow
	for rows.Next() {
		var i ListChatMessagesRow
		if err := rows.Scan(
			&i.ID,
			&i.ContestID,
			&i.UserID,
			&i.Text,
			&i.IsSystem,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserName,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCommentsByParticipant = `-- name: ListCommentsByParticipant :many
SELECT
    cc.id,
    cc.participant_id,
    cc.user_id,
    cc.text,
    cc.created_at,
    cc.updated_at,
    COALESCE(u.name, 'Пользователь ' || cc.user_id::text) AS user_name
FROM contest_comments cc
LEFT JOIN users u ON u.user_id = cc.user_id
WHERE cc.participant_id = $1
ORDER BY cc.created_at ASC
LIMIT $2 OFFSET $3
`

type ListCommentsByParticipantParams struct {
	ParticipantID pgtype.UUID
	Limit         int32
	Offset        int32
}

type ListCommentsByParticipantRow struct {
	ID            pgtype.UUID
	ParticipantID pgtype.UUID
	UserID        int64
	Text          string
	CreatedAt     pgtype.Timestamptz
	UpdatedAt     pgtype.Timestamptz
	UserName      string
}

func (q *Queries) ListCommentsByParticipant(ctx context.Context, arg *ListCommentsByParticipantParams) ([]*ListCommentsByParticipantRow, error) {
	rows, err := q.db.Query(ctx, listCommentsByParticipant, arg.ParticipantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListCommentsByParticipantRow
	for rows.Next() {
		var i ListCommentsByParticipantRow
		if err := rows.Scan(
			&i.ID,
			&i.ParticipantID,
			&i.UserID,
			&i.Text,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserName,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listContests = `-- name: ListContests :many
SELECT id, created_by_user_id, title, description, status, created_at, updated_at FROM contests
WHERE (COALESCE($1::text, '') = '' OR status = $1)
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListContestsParams struct {
	Column1 string
	Limit   int32
	Offset  int32
}

func (q *Queries) ListContests(ctx context.Context, arg *ListContestsParams) ([]*Contest, error) {
	rows, err := q.db.Query(ctx, listContests, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Contest
	for rows.Next() {
		var i Contest
		if err := rows.Scan(
			&i.ID,
			&i.CreatedByUserID,
			&i.Title,
			&i.Description,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listParticipantsByContest = `-- name: ListParticipantsByContest :many
SELECT
    cp.id,
    cp.contest_id,
    cp.user_id,
    COALESCE(u.name, 'Пользователь ' || cp.user_id::text) AS user_name,
    cp.pet_name,
    cp.pet_description,
    cp.created_at,
    cp.updated_at
FROM contest_participants cp
LEFT JOIN users u ON u.user_id = cp.user_id
WHERE cp.contest_id = $1
ORDER BY cp.created_at ASC
`

type ListParticipantsByContestRow struct {
	ID             pgtype.UUID
	ContestID      pgtype.UUID
	UserID         int64
	UserName       string
	PetName        string
	PetDescription string
	CreatedAt      pgtype.Timestamptz
	UpdatedAt      pgtype.Timestamptz
}

func (q *Queries) ListParticipantsByContest(ctx context.Context, contestID pgtype.UUID) ([]*ListParticipantsByContestRow, error) {
	rows, err := q.db.Query(ctx, listParticipantsByContest, contestID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListParticipantsByContestRow
	for rows.Next() {
		var i ListParticipantsByContestRow
		if err := rows.Scan(
			&i.ID,
			&i.ContestID,
			&i.UserID,
			&i.UserName,
			&i.PetName,
			&i.PetDescription,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPhotoLikesByPhotos = `-- name: ListPhotoLikesByPhotos :many
SELECT id, photo_id, user_id, created_at
FROM photo_likes
WHERE photo_id = ANY($1::uuid[]) AND user_id = $2
`

type ListPhotoLikesByPhotosParams struct {
	Column1 []pgtype.UUID
	UserID  int64
}

func (q *Queries) ListPhotoLikesByPhotos(ctx context.Context, arg *ListPhotoLikesByPhotosParams) ([]*PhotoLike, error) {
	rows, err := q.db.Query(ctx, listPhotoLikesByPhotos, arg.Column1, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*PhotoLike
	for rows.Next() {
		var i PhotoLike
		if err := rows.Scan(
			&i.ID,
			&i.PhotoID,
			&i.UserID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVotersByParticipant = `-- name: ListVotersByParticipant :many
SELECT
    cv.user_id,
    COALESCE(u.name, 'Пользователь ' || cv.user_id::text) AS user_name,
    cv.created_at
FROM contest_votes cv
LEFT JOIN users u ON u.user_id = cv.user_id
WHERE cv.contest_id = $1 AND cv.participant_id = $2
ORDER BY cv.created_at ASC
`

type ListVotersByParticipantParams struct {
	ContestID     pgtype.UUID
	ParticipantID pgtype.UUID
}

type ListVotersByParticipantRow struct {
	UserID    int64
	UserName  string
	CreatedAt pgtype.Timestamptz
}

func (q *Queries) ListVotersByParticipant(ctx context.Context, arg *ListVotersByParticipantParams) ([]*ListVotersByParticipantRow, error) {
	rows, err := q.db.Query(ctx, listVotersByParticipant, arg.ContestID, arg.ParticipantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListVotersByParticipantRow
	for rows.Next() {
		var i ListVotersByParticipantRow
		if err := rows.Scan(&i.UserID, &i.UserName, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateChatMessage = `-- name: UpdateChatMessage :one
UPDATE contest_chat_messages
SET text = $1, updated_at = NOW()
WHERE id = $2 AND user_id = $3 AND is_system = FALSE
RETURNING id, contest_id, user_id, text, is_system, created_at, updated_at
`

type UpdateChatMessageParams struct {
	Text   string
	ID     pgtype.UUID
	UserID int64
}

func (q *Queries) UpdateChatMessage(ctx context.Context, arg *UpdateChatMessageParams) (*ContestChatMessage, error) {
	row := q.db.QueryRow(ctx, updateChatMessage, arg.Text, arg.ID, arg.UserID)
	var i ContestChatMessage
	err := row.Scan(
		&i.ID,
		&i.ContestID,
		&i.UserID,
		&i.Text,
		&i.IsSystem,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const updateComment = `-- name: UpdateComment :one
UPDATE contest_comments
SET text = $1, updated_at = NOW()
WHERE id = $2 AND user_id = $3
RETURNING id, participant_id, user_id, text, created_at, updated_at
`

type UpdateCommentParams struct {
	Text   string
	ID     pgtype.UUID
	UserID int64
}

func (q *Queries) UpdateComment(ctx context.Context, arg *UpdateCommentParams) (*ContestComment, error) {
	row := q.db.QueryRow(ctx, updateComment, arg.Text, arg.ID, arg.UserID)
	var i ContestComment
	err := row.Scan(
		&i.ID,
		&i.ParticipantID,
		&i.UserID,
		&i.Text,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const updateContest = `-- name: UpdateContest :one
UPDATE contests
SET title = $2, description = $3, updated_at = NOW()
WHERE id = $1
RETURNING id, created_by_user_id, title, description, status, created_at, updated_at
`

type UpdateContestParams struct {
	ID          pgtype.UUID
	Title       string
	Description string
}

func (q *Queries) UpdateContest(ctx context.Context, arg *UpdateContestParams) (*Contest, error) {
	row := q.db.QueryRow(ctx, updateContest, arg.ID, arg.Title, arg.Description)
	var i Contest
	err := row.Scan(
		&i.ID,
		&i.CreatedByUserID,
		&i.Title,
		&i.Description,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const updateContestStatus = `-- name: UpdateContestStatus :one
UPDATE contests
SET status = $2, updated_at = NOW()
WHERE id = $1
RETURNING id, created_by_user_id, title, description, status, created_at, updated_at
`

type UpdateContestStatusParams struct {
	ID     pgtype.UUID
	Status string
}

func (q *Queries) UpdateContestStatus(ctx context.Context, arg *UpdateContestStatusParams) (*Contest, error) {
	row := q.db.QueryRow(ctx, updateContestStatus, arg.ID, arg.Status)
	var i Contest
	err := row.Scan(
		&i.ID,
		&i.CreatedByUserID,
		&i.Title,
		&i.Description,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const updateParticipant = `-- name: UpdateParticipant :one
UPDATE contest_participants
SET pet_name = $2, pet_description = $3, updated_at = NOW()
WHERE id = $1
RETURNING id, contest_id, user_id, pet_name, pet_description, created_at, updated_at
`

type UpdateParticipantParams struct {
	ID             pgtype.UUID
	PetName        string
	PetDescription string
}

func (q *Queries) UpdateParticipant(ctx context.Context, arg *UpdateParticipantParams) (*ContestParticipant, error) {
	row := q.db.QueryRow(ctx, updateParticipant, arg.ID, arg.PetName, arg.PetDescription)
	var i ContestParticipant
	err := row.Scan(
		&i.ID,
		&i.ContestID,
		&i.UserID,
		&i.PetName,
		&i.PetDescription,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const updateParticipantPhotoOrder = `-- name: UpdateParticipantPhotoOrder :exec
UPDATE contest_participant_photos
SET position = $3
WHERE participant_id = $1 AND id = $2
`

type UpdateParticipantPhotoOrderParams struct {
	ParticipantID pgtype.UUID
	ID            pgtype.UUID
	Position      int32
}

func (q *Queries) UpdateParticipantPhotoOrder(ctx context.Context, arg *UpdateParticipantPhotoOrderParams) error {
	_, err := q.db.Exec(ctx, updateParticipantPhotoOrder, arg.ParticipantID, arg.ID, arg.Position)
	return err
}

const updateUserName = `-- name: UpdateUserName :one
UPDATE users
SET name = $2
WHERE user_id = $1
RETURNING user_id, name, created_at
`

type UpdateUserNameParams struct {
	UserID int64
	Name   string
}

func (q *Queries) UpdateUserName(ctx context.Context, arg *UpdateUserNameParams) (*User, error) {
	row := q.db.QueryRow(ctx, updateUserName, arg.UserID, arg.Name)
	var i User
	err := row.Scan(&i.UserID, &i.Name, &i.CreatedAt)
	return &i, err
}

const upsertContestVote = `-- name: UpsertContestVote :one

INSERT INTO contest_votes (id, contest_id, participant_id, user_id)
VALUES ($1, $2, $3, $4)
ON CONFLICT (contest_id, user_id) DO UPDATE
SET participant_id = EXCLUDED.participant_id, updated_at = NOW()
RETURNING id, contest_id, participant_id, user_id, created_at, updated_at
`

type UpsertContestVoteParams struct {
	ID            pgtype.UUID
	ContestID     pgtype.UUID
	ParticipantID pgtype.UUID
	UserID        int64
}

// Contest Votes
func (q *Queries) UpsertContestVote(ctx context.Context, arg *UpsertContestVoteParams) (*ContestVote, error) {
	row := q.db.QueryRow(ctx, upsertContestVote,
		arg.ID,
		arg.ContestID,
		arg.ParticipantID,
		arg.UserID,
	)
	var i ContestVote
	err := row.Scan(
		&i.ID,
		&i.ContestID,
		&i.ParticipantID,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const upsertParticipantVideo = `-- name: UpsertParticipantVideo :one

INSERT INTO contest_participant_videos (id, participant_id, url)
VALUES ($1, $2, $3)
ON CONFLICT (participant_id) DO UPDATE
SET id = EXCLUDED.id, url = EXCLUDED.url, created_at = NOW()
RETURNING id, participant_id, url, created_at
`

type UpsertParticipantVideoParams struct {
	ID            pgtype.UUID
	ParticipantID pgtype.UUID
	Url           string
}

// Contest Participant Videos
func (q *Queries) UpsertParticipantVideo(ctx context.Context, arg *UpsertParticipantVideoParams) (*ContestParticipantVideo, error) {
	row := q.db.QueryRow(ctx, upsertParticipantVideo, arg.ID, arg.ParticipantID, arg.Url)
	var i ContestParticipantVideo
	err := row.Scan(
		&i.ID,
		&i.ParticipantID,
		&i.Url,
		&i.CreatedAt,
	)
	return &i, err
}

const upsertPhotoLike = `-- name: UpsertPhotoLike :one

INSERT INTO photo_likes (id, photo_id, user_id)
VALUES ($1, $2, $3)
ON CONFLICT (photo_id, user_id) DO UPDATE
SET id = photo_likes.id
RETURNING id, photo_id, user_id, created_at
`

type UpsertPhotoLikeParams struct {
	ID      pgtype.UUID
	PhotoID pgtype.UUID
	UserID  int64
}

// Photo Likes
func (q *Queries) UpsertPhotoLike(ctx context.Context, arg *UpsertPhotoLikeParams) (*PhotoLike, error) {
	row := q.db.QueryRow(ctx, upsertPhotoLike, arg.ID, arg.PhotoID, arg.UserID)
	var i PhotoLike
	err := row.Scan(
		&i.ID,
		&i.PhotoID,
		&i.UserID,
		&i.CreatedAt,
	)
	return &i, err
}
