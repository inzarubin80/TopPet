// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package sqlc_repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addParticipantPhoto = `-- name: AddParticipantPhoto :one

INSERT INTO contest_participant_photos (id, participant_id, url, thumb_url)
VALUES ($1, $2, $3, $4)
RETURNING id, participant_id, url, thumb_url, created_at
`

type AddParticipantPhotoParams struct {
	ID            pgtype.UUID
	ParticipantID pgtype.UUID
	Url           string
	ThumbUrl      *string
}

// Contest Participant Photos
func (q *Queries) AddParticipantPhoto(ctx context.Context, arg *AddParticipantPhotoParams) (*ContestParticipantPhoto, error) {
	row := q.db.QueryRow(ctx, addParticipantPhoto,
		arg.ID,
		arg.ParticipantID,
		arg.Url,
		arg.ThumbUrl,
	)
	var i ContestParticipantPhoto
	err := row.Scan(
		&i.ID,
		&i.ParticipantID,
		&i.Url,
		&i.ThumbUrl,
		&i.CreatedAt,
	)
	return &i, err
}

const addUserAuthProviders = `-- name: AddUserAuthProviders :one
INSERT INTO user_auth_providers (user_id, provider_uid, provider, name)
VALUES ($1, $2, $3, $4)
RETURNING user_id, provider_uid, provider, name
`

type AddUserAuthProvidersParams struct {
	UserID      int64
	ProviderUid string
	Provider    string
	Name        *string
}

func (q *Queries) AddUserAuthProviders(ctx context.Context, arg *AddUserAuthProvidersParams) (*UserAuthProvider, error) {
	row := q.db.QueryRow(ctx, addUserAuthProviders,
		arg.UserID,
		arg.ProviderUid,
		arg.Provider,
		arg.Name,
	)
	var i UserAuthProvider
	err := row.Scan(
		&i.UserID,
		&i.ProviderUid,
		&i.Provider,
		&i.Name,
	)
	return &i, err
}

const countChatMessages = `-- name: CountChatMessages :one
SELECT count(1) FROM contest_chat_messages
WHERE contest_id = $1
`

func (q *Queries) CountChatMessages(ctx context.Context, contestID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countChatMessages, contestID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countCommentsByParticipant = `-- name: CountCommentsByParticipant :one
SELECT count(1) FROM contest_comments
WHERE participant_id = $1
`

func (q *Queries) CountCommentsByParticipant(ctx context.Context, participantID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countCommentsByParticipant, participantID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countContests = `-- name: CountContests :one
SELECT count(1) FROM contests
WHERE ($1::text IS NULL OR status = $1)
`

func (q *Queries) CountContests(ctx context.Context, dollar_1 string) (int64, error) {
	row := q.db.QueryRow(ctx, countContests, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countVotesByContest = `-- name: CountVotesByContest :one
SELECT count(1) FROM contest_votes
WHERE contest_id = $1
`

func (q *Queries) CountVotesByContest(ctx context.Context, contestID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countVotesByContest, contestID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countVotesByParticipant = `-- name: CountVotesByParticipant :one
SELECT count(1) FROM contest_votes
WHERE participant_id = $1
`

func (q *Queries) CountVotesByParticipant(ctx context.Context, participantID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countVotesByParticipant, participantID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createChatMessage = `-- name: CreateChatMessage :one

INSERT INTO contest_chat_messages (id, contest_id, user_id, text, is_system)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, contest_id, user_id, text, is_system, created_at, updated_at
`

type CreateChatMessageParams struct {
	ID        pgtype.UUID
	ContestID pgtype.UUID
	UserID    int64
	Text      string
	IsSystem  bool
}

// Contest Chat Messages
func (q *Queries) CreateChatMessage(ctx context.Context, arg *CreateChatMessageParams) (*ContestChatMessage, error) {
	row := q.db.QueryRow(ctx, createChatMessage,
		arg.ID,
		arg.ContestID,
		arg.UserID,
		arg.Text,
		arg.IsSystem,
	)
	var i ContestChatMessage
	err := row.Scan(
		&i.ID,
		&i.ContestID,
		&i.UserID,
		&i.Text,
		&i.IsSystem,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createComment = `-- name: CreateComment :one

INSERT INTO contest_comments (id, participant_id, user_id, text)
VALUES ($1, $2, $3, $4)
RETURNING id, participant_id, user_id, text, created_at, updated_at
`

type CreateCommentParams struct {
	ID            pgtype.UUID
	ParticipantID pgtype.UUID
	UserID        int64
	Text          string
}

// Contest Comments
func (q *Queries) CreateComment(ctx context.Context, arg *CreateCommentParams) (*ContestComment, error) {
	row := q.db.QueryRow(ctx, createComment,
		arg.ID,
		arg.ParticipantID,
		arg.UserID,
		arg.Text,
	)
	var i ContestComment
	err := row.Scan(
		&i.ID,
		&i.ParticipantID,
		&i.UserID,
		&i.Text,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createContest = `-- name: CreateContest :one

INSERT INTO contests (id, created_by_user_id, title, description, status)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, created_by_user_id, title, description, status, created_at, updated_at
`

type CreateContestParams struct {
	ID              pgtype.UUID
	CreatedByUserID int64
	Title           string
	Description     string
	Status          string
}

// Contests
func (q *Queries) CreateContest(ctx context.Context, arg *CreateContestParams) (*Contest, error) {
	row := q.db.QueryRow(ctx, createContest,
		arg.ID,
		arg.CreatedByUserID,
		arg.Title,
		arg.Description,
		arg.Status,
	)
	var i Contest
	err := row.Scan(
		&i.ID,
		&i.CreatedByUserID,
		&i.Title,
		&i.Description,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createParticipant = `-- name: CreateParticipant :one

INSERT INTO contest_participants (id, contest_id, user_id, pet_name, pet_description)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, contest_id, user_id, pet_name, pet_description, created_at, updated_at
`

type CreateParticipantParams struct {
	ID             pgtype.UUID
	ContestID      pgtype.UUID
	UserID         int64
	PetName        string
	PetDescription string
}

// Contest Participants
func (q *Queries) CreateParticipant(ctx context.Context, arg *CreateParticipantParams) (*ContestParticipant, error) {
	row := q.db.QueryRow(ctx, createParticipant,
		arg.ID,
		arg.ContestID,
		arg.UserID,
		arg.PetName,
		arg.PetDescription,
	)
	var i ContestParticipant
	err := row.Scan(
		&i.ID,
		&i.ContestID,
		&i.UserID,
		&i.PetName,
		&i.PetDescription,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createUser = `-- name: CreateUser :one

INSERT INTO users (name)
VALUES ($1)
RETURNING user_id, name, created_at
`

// Users
func (q *Queries) CreateUser(ctx context.Context, name string) (*User, error) {
	row := q.db.QueryRow(ctx, createUser, name)
	var i User
	err := row.Scan(&i.UserID, &i.Name, &i.CreatedAt)
	return &i, err
}

const deleteChatMessage = `-- name: DeleteChatMessage :exec
DELETE FROM contest_chat_messages
WHERE id = $1 AND user_id = $2 AND is_system = FALSE
`

type DeleteChatMessageParams struct {
	ID     pgtype.UUID
	UserID int64
}

func (q *Queries) DeleteChatMessage(ctx context.Context, arg *DeleteChatMessageParams) error {
	_, err := q.db.Exec(ctx, deleteChatMessage, arg.ID, arg.UserID)
	return err
}

const deleteComment = `-- name: DeleteComment :exec
DELETE FROM contest_comments
WHERE id = $1 AND user_id = $2
`

type DeleteCommentParams struct {
	ID     pgtype.UUID
	UserID int64
}

func (q *Queries) DeleteComment(ctx context.Context, arg *DeleteCommentParams) error {
	_, err := q.db.Exec(ctx, deleteComment, arg.ID, arg.UserID)
	return err
}

const deleteParticipantPhoto = `-- name: DeleteParticipantPhoto :exec
DELETE FROM contest_participant_photos
WHERE id = $1
`

func (q *Queries) DeleteParticipantPhoto(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteParticipantPhoto, id)
	return err
}

const deleteParticipantVideo = `-- name: DeleteParticipantVideo :exec
DELETE FROM contest_participant_videos
WHERE participant_id = $1
`

func (q *Queries) DeleteParticipantVideo(ctx context.Context, participantID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteParticipantVideo, participantID)
	return err
}

const getCommentByID = `-- name: GetCommentByID :one
SELECT id, participant_id, user_id, text, created_at, updated_at FROM contest_comments WHERE id = $1
`

func (q *Queries) GetCommentByID(ctx context.Context, id pgtype.UUID) (*ContestComment, error) {
	row := q.db.QueryRow(ctx, getCommentByID, id)
	var i ContestComment
	err := row.Scan(
		&i.ID,
		&i.ParticipantID,
		&i.UserID,
		&i.Text,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getContestByID = `-- name: GetContestByID :one
SELECT id, created_by_user_id, title, description, status, created_at, updated_at FROM contests WHERE id = $1
`

func (q *Queries) GetContestByID(ctx context.Context, id pgtype.UUID) (*Contest, error) {
	row := q.db.QueryRow(ctx, getContestByID, id)
	var i Contest
	err := row.Scan(
		&i.ID,
		&i.CreatedByUserID,
		&i.Title,
		&i.Description,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getContestVoteByUser = `-- name: GetContestVoteByUser :one
SELECT id, contest_id, participant_id, user_id, created_at, updated_at FROM contest_votes
WHERE contest_id = $1 AND user_id = $2
`

type GetContestVoteByUserParams struct {
	ContestID pgtype.UUID
	UserID    int64
}

func (q *Queries) GetContestVoteByUser(ctx context.Context, arg *GetContestVoteByUserParams) (*ContestVote, error) {
	row := q.db.QueryRow(ctx, getContestVoteByUser, arg.ContestID, arg.UserID)
	var i ContestVote
	err := row.Scan(
		&i.ID,
		&i.ContestID,
		&i.ParticipantID,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getParticipantByContestAndUser = `-- name: GetParticipantByContestAndUser :one
SELECT id, contest_id, user_id, pet_name, pet_description, created_at, updated_at FROM contest_participants
WHERE contest_id = $1 AND user_id = $2
`

type GetParticipantByContestAndUserParams struct {
	ContestID pgtype.UUID
	UserID    int64
}

func (q *Queries) GetParticipantByContestAndUser(ctx context.Context, arg *GetParticipantByContestAndUserParams) (*ContestParticipant, error) {
	row := q.db.QueryRow(ctx, getParticipantByContestAndUser, arg.ContestID, arg.UserID)
	var i ContestParticipant
	err := row.Scan(
		&i.ID,
		&i.ContestID,
		&i.UserID,
		&i.PetName,
		&i.PetDescription,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getParticipantByID = `-- name: GetParticipantByID :one
SELECT id, contest_id, user_id, pet_name, pet_description, created_at, updated_at FROM contest_participants WHERE id = $1
`

func (q *Queries) GetParticipantByID(ctx context.Context, id pgtype.UUID) (*ContestParticipant, error) {
	row := q.db.QueryRow(ctx, getParticipantByID, id)
	var i ContestParticipant
	err := row.Scan(
		&i.ID,
		&i.ContestID,
		&i.UserID,
		&i.PetName,
		&i.PetDescription,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getPhotosByParticipantID = `-- name: GetPhotosByParticipantID :many
SELECT id, participant_id, url, thumb_url, created_at FROM contest_participant_photos
WHERE participant_id = $1
ORDER BY created_at ASC
`

func (q *Queries) GetPhotosByParticipantID(ctx context.Context, participantID pgtype.UUID) ([]*ContestParticipantPhoto, error) {
	rows, err := q.db.Query(ctx, getPhotosByParticipantID, participantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ContestParticipantPhoto
	for rows.Next() {
		var i ContestParticipantPhoto
		if err := rows.Scan(
			&i.ID,
			&i.ParticipantID,
			&i.Url,
			&i.ThumbUrl,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserAuthProvidersByProviderUid = `-- name: GetUserAuthProvidersByProviderUid :one
SELECT user_id, provider_uid, provider, name FROM user_auth_providers
WHERE provider_uid = $1 AND provider = $2
`

type GetUserAuthProvidersByProviderUidParams struct {
	ProviderUid string
	Provider    string
}

func (q *Queries) GetUserAuthProvidersByProviderUid(ctx context.Context, arg *GetUserAuthProvidersByProviderUidParams) (*UserAuthProvider, error) {
	row := q.db.QueryRow(ctx, getUserAuthProvidersByProviderUid, arg.ProviderUid, arg.Provider)
	var i UserAuthProvider
	err := row.Scan(
		&i.UserID,
		&i.ProviderUid,
		&i.Provider,
		&i.Name,
	)
	return &i, err
}

const getUserAuthProvidersByUserID = `-- name: GetUserAuthProvidersByUserID :many
SELECT user_id, provider_uid, provider, name FROM user_auth_providers
WHERE user_id = $1
`

func (q *Queries) GetUserAuthProvidersByUserID(ctx context.Context, userID int64) ([]*UserAuthProvider, error) {
	rows, err := q.db.Query(ctx, getUserAuthProvidersByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*UserAuthProvider
	for rows.Next() {
		var i UserAuthProvider
		if err := rows.Scan(
			&i.UserID,
			&i.ProviderUid,
			&i.Provider,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByID = `-- name: GetUserByID :one
SELECT user_id, name, created_at FROM users
WHERE user_id = $1
`

func (q *Queries) GetUserByID(ctx context.Context, userID int64) (*User, error) {
	row := q.db.QueryRow(ctx, getUserByID, userID)
	var i User
	err := row.Scan(&i.UserID, &i.Name, &i.CreatedAt)
	return &i, err
}

const getVideoByParticipantID = `-- name: GetVideoByParticipantID :one
SELECT id, participant_id, url, created_at FROM contest_participant_videos
WHERE participant_id = $1
`

func (q *Queries) GetVideoByParticipantID(ctx context.Context, participantID pgtype.UUID) (*ContestParticipantVideo, error) {
	row := q.db.QueryRow(ctx, getVideoByParticipantID, participantID)
	var i ContestParticipantVideo
	err := row.Scan(
		&i.ID,
		&i.ParticipantID,
		&i.Url,
		&i.CreatedAt,
	)
	return &i, err
}

const listChatMessages = `-- name: ListChatMessages :many
SELECT id, contest_id, user_id, text, is_system, created_at, updated_at FROM contest_chat_messages
WHERE contest_id = $1
ORDER BY created_at ASC
LIMIT $2 OFFSET $3
`

type ListChatMessagesParams struct {
	ContestID pgtype.UUID
	Limit     int32
	Offset    int32
}

func (q *Queries) ListChatMessages(ctx context.Context, arg *ListChatMessagesParams) ([]*ContestChatMessage, error) {
	rows, err := q.db.Query(ctx, listChatMessages, arg.ContestID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ContestChatMessage
	for rows.Next() {
		var i ContestChatMessage
		if err := rows.Scan(
			&i.ID,
			&i.ContestID,
			&i.UserID,
			&i.Text,
			&i.IsSystem,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCommentsByParticipant = `-- name: ListCommentsByParticipant :many
SELECT id, participant_id, user_id, text, created_at, updated_at FROM contest_comments
WHERE participant_id = $1
ORDER BY created_at ASC
LIMIT $2 OFFSET $3
`

type ListCommentsByParticipantParams struct {
	ParticipantID pgtype.UUID
	Limit         int32
	Offset        int32
}

func (q *Queries) ListCommentsByParticipant(ctx context.Context, arg *ListCommentsByParticipantParams) ([]*ContestComment, error) {
	rows, err := q.db.Query(ctx, listCommentsByParticipant, arg.ParticipantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ContestComment
	for rows.Next() {
		var i ContestComment
		if err := rows.Scan(
			&i.ID,
			&i.ParticipantID,
			&i.UserID,
			&i.Text,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listContests = `-- name: ListContests :many
SELECT id, created_by_user_id, title, description, status, created_at, updated_at FROM contests
WHERE ($1::text IS NULL OR status = $1)
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListContestsParams struct {
	Column1 string
	Limit   int32
	Offset  int32
}

func (q *Queries) ListContests(ctx context.Context, arg *ListContestsParams) ([]*Contest, error) {
	rows, err := q.db.Query(ctx, listContests, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Contest
	for rows.Next() {
		var i Contest
		if err := rows.Scan(
			&i.ID,
			&i.CreatedByUserID,
			&i.Title,
			&i.Description,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listParticipantsByContest = `-- name: ListParticipantsByContest :many
SELECT id, contest_id, user_id, pet_name, pet_description, created_at, updated_at FROM contest_participants
WHERE contest_id = $1
ORDER BY created_at ASC
`

func (q *Queries) ListParticipantsByContest(ctx context.Context, contestID pgtype.UUID) ([]*ContestParticipant, error) {
	rows, err := q.db.Query(ctx, listParticipantsByContest, contestID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ContestParticipant
	for rows.Next() {
		var i ContestParticipant
		if err := rows.Scan(
			&i.ID,
			&i.ContestID,
			&i.UserID,
			&i.PetName,
			&i.PetDescription,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateChatMessage = `-- name: UpdateChatMessage :one
UPDATE contest_chat_messages
SET text = $1, updated_at = NOW()
WHERE id = $2 AND user_id = $3 AND is_system = FALSE
RETURNING id, contest_id, user_id, text, is_system, created_at, updated_at
`

type UpdateChatMessageParams struct {
	Text   string
	ID     pgtype.UUID
	UserID int64
}

func (q *Queries) UpdateChatMessage(ctx context.Context, arg *UpdateChatMessageParams) (*ContestChatMessage, error) {
	row := q.db.QueryRow(ctx, updateChatMessage, arg.Text, arg.ID, arg.UserID)
	var i ContestChatMessage
	err := row.Scan(
		&i.ID,
		&i.ContestID,
		&i.UserID,
		&i.Text,
		&i.IsSystem,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const updateComment = `-- name: UpdateComment :one
UPDATE contest_comments
SET text = $1, updated_at = NOW()
WHERE id = $2 AND user_id = $3
RETURNING id, participant_id, user_id, text, created_at, updated_at
`

type UpdateCommentParams struct {
	Text   string
	ID     pgtype.UUID
	UserID int64
}

func (q *Queries) UpdateComment(ctx context.Context, arg *UpdateCommentParams) (*ContestComment, error) {
	row := q.db.QueryRow(ctx, updateComment, arg.Text, arg.ID, arg.UserID)
	var i ContestComment
	err := row.Scan(
		&i.ID,
		&i.ParticipantID,
		&i.UserID,
		&i.Text,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const updateContest = `-- name: UpdateContest :one
UPDATE contests
SET title = $2, description = $3, updated_at = NOW()
WHERE id = $1
RETURNING id, created_by_user_id, title, description, status, created_at, updated_at
`

type UpdateContestParams struct {
	ID          pgtype.UUID
	Title       string
	Description string
}

func (q *Queries) UpdateContest(ctx context.Context, arg *UpdateContestParams) (*Contest, error) {
	row := q.db.QueryRow(ctx, updateContest, arg.ID, arg.Title, arg.Description)
	var i Contest
	err := row.Scan(
		&i.ID,
		&i.CreatedByUserID,
		&i.Title,
		&i.Description,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const updateContestStatus = `-- name: UpdateContestStatus :one
UPDATE contests
SET status = $2, updated_at = NOW()
WHERE id = $1
RETURNING id, created_by_user_id, title, description, status, created_at, updated_at
`

type UpdateContestStatusParams struct {
	ID     pgtype.UUID
	Status string
}

func (q *Queries) UpdateContestStatus(ctx context.Context, arg *UpdateContestStatusParams) (*Contest, error) {
	row := q.db.QueryRow(ctx, updateContestStatus, arg.ID, arg.Status)
	var i Contest
	err := row.Scan(
		&i.ID,
		&i.CreatedByUserID,
		&i.Title,
		&i.Description,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const updateParticipant = `-- name: UpdateParticipant :one
UPDATE contest_participants
SET pet_name = $2, pet_description = $3, updated_at = NOW()
WHERE id = $1
RETURNING id, contest_id, user_id, pet_name, pet_description, created_at, updated_at
`

type UpdateParticipantParams struct {
	ID             pgtype.UUID
	PetName        string
	PetDescription string
}

func (q *Queries) UpdateParticipant(ctx context.Context, arg *UpdateParticipantParams) (*ContestParticipant, error) {
	row := q.db.QueryRow(ctx, updateParticipant, arg.ID, arg.PetName, arg.PetDescription)
	var i ContestParticipant
	err := row.Scan(
		&i.ID,
		&i.ContestID,
		&i.UserID,
		&i.PetName,
		&i.PetDescription,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const upsertContestVote = `-- name: UpsertContestVote :one

INSERT INTO contest_votes (id, contest_id, participant_id, user_id)
VALUES ($1, $2, $3, $4)
ON CONFLICT (contest_id, user_id) DO UPDATE
SET participant_id = EXCLUDED.participant_id, updated_at = NOW()
RETURNING id, contest_id, participant_id, user_id, created_at, updated_at
`

type UpsertContestVoteParams struct {
	ID            pgtype.UUID
	ContestID     pgtype.UUID
	ParticipantID pgtype.UUID
	UserID        int64
}

// Contest Votes
func (q *Queries) UpsertContestVote(ctx context.Context, arg *UpsertContestVoteParams) (*ContestVote, error) {
	row := q.db.QueryRow(ctx, upsertContestVote,
		arg.ID,
		arg.ContestID,
		arg.ParticipantID,
		arg.UserID,
	)
	var i ContestVote
	err := row.Scan(
		&i.ID,
		&i.ContestID,
		&i.ParticipantID,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const upsertParticipantVideo = `-- name: UpsertParticipantVideo :one

INSERT INTO contest_participant_videos (id, participant_id, url)
VALUES ($1, $2, $3)
ON CONFLICT (participant_id) DO UPDATE
SET id = EXCLUDED.id, url = EXCLUDED.url, created_at = NOW()
RETURNING id, participant_id, url, created_at
`

type UpsertParticipantVideoParams struct {
	ID            pgtype.UUID
	ParticipantID pgtype.UUID
	Url           string
}

// Contest Participant Videos
func (q *Queries) UpsertParticipantVideo(ctx context.Context, arg *UpsertParticipantVideoParams) (*ContestParticipantVideo, error) {
	row := q.db.QueryRow(ctx, upsertParticipantVideo, arg.ID, arg.ParticipantID, arg.Url)
	var i ContestParticipantVideo
	err := row.Scan(
		&i.ID,
		&i.ParticipantID,
		&i.Url,
		&i.CreatedAt,
	)
	return &i, err
}
